const Joi = require("joi");
const Xdb = require("./Xdb");
const Xerror = require("./Xerror");

class Xcrud {
    constructor(table, schema) {
        this.table = table;
        this.schemaCreate = schema.clone();
        this.schemaCreateMany = Joi.array().items(this.schemaCreate).min(1);
        this.schemaRead = this.cleanSchema(schema).append({
            id: Joi.number().integer(),
            page: Joi.number(),
            limit: Joi.number(),
            created_at: Joi.date(),
            from_date: Joi.date(),
            to_date: Joi.date(),
            count: Joi.boolean()
        });
        this.schemaUpdate = schema.append({ id: Joi.number().integer() });
        this.schemaDel = Joi.object({ id: Joi.number().integer() });

        this.E = {
            data: new Xerror(`Dữ liệu không hợp lệ !`, { status: 403, code: 'DATA_INVALID' }),
            create: new Xerror(`Không thể tạo ${table} !`, { status: 500, code: 'CREATE_FAIL' }),
            read: new Xerror(`Không thể đọc ${table} !`, { status: 500, code: 'READ_FAIL' }),
            update: new Xerror(`Không thể cập nhật ${table} !`, { status: 500, code: 'UPDATE_FAIL' }),
            del: new Xerror(`Không thể xoá ${table} !`, { status: 500, code: 'DELETE_FAIL' })
        };

    }
    async CreateMany(data, required) {
        try {
            data = data.map(obj => Object.fromEntries(Object.entries(obj).filter(([, v]) => v !== undefined)));
            const dataArr = this.validate(this.schemaCreateMany, data, required);
            const ids = await Xdb.transaction(async (executor) => await executor.insertMany(this.table, dataArr));
            return ids;
        } catch (e) { throw this.E.create; }
    }
    async create(data, required) {
        try {
            data = Object.fromEntries(Object.entries(data).filter(([_, v]) => v !== undefined));
            const value = this.validate(this.schemaCreate, data, required);
            return await Xdb.insert(this.table, value);
        } catch (e) { throw this.E.create; }
    }
    async read(data = {}, required, fields = [], options = {}) {
        try {
            data = Object.fromEntries(Object.entries(data).filter(([_, v]) => v !== undefined && v !== ""));
            const { from_date, to_date, count, page = 1, limit = 20, ...value } = this.validate(this.schemaRead, data, required);
            const w = new Xdb.whereBuilder();
            const describe = this.schemaUpdate.describe().keys;
            for (const v of Object.keys(describe)) {
                if (value[v] === undefined) continue;
                if (options.verify || ['number', 'boolean'].includes(describe[v].type)) { w.add(`${v} = ?`, value[v]); continue; }
                if (describe[v].type == 'string') { w.add(`${v} LIKE ?`, `%${value[v]}%`); continue; }
            }
            w.add('created_at BETWEEN ? AND ?', [from_date, to_date]);
            delete options.verify;
            options.limit = options.limit || limit;
            options.offset = (page - 1) * options.limit;
            if (count) return await Xdb.selectCount(this.table, w.where(), w.params());
            return await Xdb.select(this.table, fields, w.where(), w.params(), options);
        } catch (e) { throw this.E.read; }
    }

    async readBy(key, value, fields) {
        try {
            const [result] = await Xdb.select(this.table, fields, `${key} = ?`, [value], { limit: 1 });
            return result;
        } catch (e) { throw this.E.read; }
    }
    async update(id_v, data, fields = []) {
        try {
            data = Object.fromEntries(Object.entries(data).filter(([_, v]) => v !== undefined));
            const { id, ...value } = this.validate(this.schemaUpdate, { ...data, id: id_v }, ['id']);

            const filtered = {};
            for (const key of fields) {
                if (key in value) filtered[key] = value[key];
            }

            if (Object.keys(filtered).length === 0) throw this.E.data;

            await Xdb.update(this.table, filtered, 'id = ?', [id]);
            return true;
        } catch (e) { throw this.E.update; }
    }

    async del(id_v) {
        try {
            const { id } = this.validate(this.schemaDel, { id: id_v }, ['id']);
            await Xdb.delete(this.table, 'id = ?', [id]);
            return true;
        } catch (e) { throw this.E.del; }
    }
    validate(schema, data, required = []) {
        let s;
        if (schema.type === 'array' && required.length) {
            // Nếu là array schema, fork từng item trong mảng
            const item = schema.$_terms.items?.[0]; // lấy schema bên trong items()
            s = Joi.array().items(item.fork(required, f => f.required())).min(1);
        } else {
            s = schema.clone();
            if (required.length) {
                s = s.fork(required, f => f.required());
            }
        }

        const { error, value } = s.validate(data, { convert: true });
        if (error) throw this.E.data;

        return value;
    }
    cleanSchema(schema) {
        const described = schema.describe();
        function build(schemaDesc) {
            switch (schemaDesc.type) {
                case 'object': {
                    const keys = {};
                    for (const key in schemaDesc.keys) {
                        keys[key] = build(schemaDesc.keys[key]);
                    }
                    return Joi.object(keys);
                }
                case 'string':
                    return Joi.string();
                case 'number':
                    return Joi.number();
                case 'boolean':
                    return Joi.boolean();
                case 'date':
                    return Joi.date();
                case 'array':
                    return Joi.array();
                default:
                    return Joi.any();
            }
        }

        return build(described);
    }

}

module.exports = Xcrud;
