const async = require('async');
const Xtime = require('./Xtime');
const Xapi = require('./Xapi');
const Xproxy = require('./Xproxy');
const { Mutex } = require("async-mutex");

class Xqueue {
    #shiftMt = new Mutex();
    constructor(handle, nTask = 1, xTask = 1) {
        this.handle = handle;
        this.nTask = nTask;
        this.xTask = xTask;
        this.listWork = [];
        this.listProxy = {};
    }
    #cronProxy = false;
    async stop() { this.#cronProxy = false; }
    async start() {
        this.#cronProxy = true;
        while (this.#cronProxy) {
            let list = await Xapi.proxy.get();
            list.forEach(v => { if (!this.listProxy[v.host]) this.#run(v); })
            Object.keys(this.listProxy).filter(k => Date.now() - this.listProxy[k] > (1000 * 60 * 30)).forEach(k => delete this.listProxy[k]);
            await Xtime.sleep(10000);
        }
    }
    async #run({ host, port, username, password }) {
        if (this.listProxy[host]) return; else this.listProxy[host] = Date.now();
        let worker = new async.queue(this.handle, this.nTask);
        let proxy = new Xproxy('http', host, port, username, password);
        proxy.live = true;
        while (proxy.live) {
            let task = this.nTask * this.xTask - worker.length()
            if (task > 0) worker.push((await this.getWork(task)).map(data => ({ data, proxy })));
            await Xtime.sleep(1000);
        }
        this.listWork.push(...this.pendingWork(worker));
        worker.kill();
    }
    pendingWork(queue) {
        return queue.tasks?.map(t => t.data) || [];
    }
    getWork(count = 1) {
        return this.#shiftMt.runExclusive(() => this.listWork.splice(0, count));
    }
    addWork(works) {
        if (!Array.isArray(works)) works = [works];
        this.listWork.push(...works);
    }
}

module.exports = Xqueue;
