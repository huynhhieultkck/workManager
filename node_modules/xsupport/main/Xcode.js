const CryptoJS = require("crypto-js");
const crypto = require('crypto');
const uuid = require('uuid');
const { authenticator } = require('otplib');
const JWT = require('jsonwebtoken');
const bcrypt = require('bcryptjs');

class Xcode {
    constructor() { }

    static alias = {
        dotCount: (email) => 1 << (email.split('@')[0].length - 1),
        plus: (email) => `${email.split('@')[0]}+${Xcode.string.random(5, 'abcdefghijklmnopqrstuvwxyz0123456789')}@${email.split('@')[1]}`,
        dot: (email) => {
            const [u, d] = email.split('@'), m = Math.floor(Math.random() * (1 << (u.length - 1)));
            return u.split('').map((c, i) => c + (i < u.length - 1 && m & (1 << i) ? '.' : '')).join('') + '@' + d;
        },
        random: (email, dot = true, plus = true) => {
            if (dot) email = Xcode.alias.dot(email);
            if (plus) email = Xcode.alias.plus(email);
            return email;
        }
    }

    static base64 = {
        encode: (str) => btoa(unescape(encodeURIComponent(str))),
        decode: (str) => {
            str = str.replace(/-/g, '+').replace(/_/g, '/');
            while (str.length % 4) { str += '='; }
            return atob(str);
        }
    }

    static url = {
        encode: (str) => encodeURIComponent(str),
        decode: (str) => decodeURIComponent(str)
    }

    static html = {
        encode: (str) => str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;"),
        // decode: (str) => { let rs = document.createElement('textarea'); rs.innerHTML = str; return rs.value; }
    }

    static hex = {
        encode: (str) => Array.from(str).map(c => c.charCodeAt(0).toString(16).padStart(2, '0')).join(''),
        decode: (str) => str.match(/.{1,2}/g).map(byte => String.fromCharCode(parseInt(byte, 16))).join('')
    }

    static ascii = {
        encode: (str) => Array.from(str).map(char => char.charCodeAt(0)),
        decode: (str) => str.map(code => String.fromCharCode(code)).join('')
    }

    static jwt = {
        decode: (str) => JSON.parse(Xcode.base64.decode(str.split('.')[1])),
        sign: (payload, secretKey, expiresIn) => JWT.sign(payload, secretKey, { expiresIn }),
        verify: (token, secretKey) => JWT.verify(token, secretKey)
    }

    static caesar = {
        encode: (str, shift = 3) => str.replace(/[a-z]/gi, c => String.fromCharCode(((c.toLowerCase().charCodeAt(0) - 97 + shift) % 26) + 97)),
        decode: (str, shift = 3) => Xcode.caesar.encode(str, 26 - shift)
    }

    static binary = {
        encode: (str) => str.split('').map(c => c.charCodeAt(0).toString(2).padStart(8, '0')).join(' '),
        decode: (str) => str.split(' ').map(bin => String.fromCharCode(parseInt(bin, 2))).join('')
    }

    static hash = {
        encode: {
            md5: (str) => CryptoJS.MD5(str).toString(),
            sha1: (str) => CryptoJS.SHA1(str).toString(),
            sha256: (str) => CryptoJS.SHA256(str).toString(),
            sha512: (str) => CryptoJS.SHA512(str).toString()
        }
    }

    static uuid = {
        v1: () => uuid.v1(),
        v3: () => uuid.v3(),
        v4: () => uuid.v4(),
        v5: () => uuid.v5(),
        v2: () => uuid.v2()
    }

    static base64Url = {
        encode: (str) => btoa(str).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, ''),
        decode: (str) => {
            str = str.replace(/-/g, '+').replace(/_/g, '/');
            while (str.length % 4) { str += '='; }
            return atob(str);
        }
    }
    static PKCE(length = 32) {
        const toB64Url = b => b.toString('base64').replace(/=/g, '').replace(/\+/g, '-').replace(/\//g, '_');
        const v = typeof length === 'number' ? toB64Url(crypto.randomBytes(Math.ceil(length * 3 / 4))).slice(0, length) : length;
        return { code_verifier: v, code_challenge: toB64Url(crypto.createHash('sha256').update(v).digest()) };
    }

    static twoFA(secret) {
        return authenticator.generate(secret);
    }
    static generateSignature(data, secretKey) {
        return crypto.createHmac('sha256', secretKey).update(data).digest('hex');
    }
    static password = {
        hash: (pass) => bcrypt.hashSync(pass, 10),
        compare: (pass, hPass) => bcrypt.compareSync(pass, hPass)
    }
    static string = {
        random: (length = 1, kyTu = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789') => {
            let array = new Uint32Array(length);
            crypto.getRandomValues(array);
            return Array.from(array, x => kyTu[x % kyTu.length]).join('');
        },
        randomPass: (length = 12) => Xcode.string.random(length, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%&"),
        includesArray: (text, array, checkAllArray = false) => array[checkAllArray ? 'every' : 'some'](v => new RegExp(v).test(text))
    }
    static number = {
        random: (min, max) => Math.floor(Math.random() * (Math.floor(max) - Math.ceil(min) + 1)) + Math.ceil(min),
        round: (num, decimals = 2) => Number(num.toFixed(decimals)),
        formatNumber: (num) => num.toLocaleString(),
        padNumber: (num, length) => num.toString().padStart(length, '0')
    }
}


module.exports = Xcode;

