const fs = require('fs');
const rl = require('readline')
const path = require('path');
const Joi = require('joi');

class Xfile {

    static show = false;

    constructor() {
    }

    static read(filePath) {
        let { error } = Joi.string().required().validate(filePath);
        if (error) throw error;

        try {
            return fs.readFileSync(filePath, 'utf8');
        } catch (err) {
            if (Xfile.show) console.log(`Lỗi đọc file !`, err);
            return '';
        }
    }

    static readAllLine(filePath) {
        return (this.read(filePath) || "")
            .trim()
            .split("\n")
            .map(v => v.trim())
            .filter(Boolean);
    }

    static write(filePath, text, overwrite = false) {
        let { error } = Joi.object({
            filePath: Joi.string().required(),
            text: Joi.string().allow(''),
            overwrite: Joi.bool().required()
        }).validate({ filePath, text, overwrite });
        if (error) throw error;


        try {
            (overwrite ? fs.writeFileSync : fs.appendFileSync)(filePath, text, 'utf8');
            return true;
        } catch (err) {
            if (Xfile.show) console.log('Lỗi ghi file !', err);
            return false;
        }
    }



    static writeLine(filePath, text) {
        return this.write(filePath, text.trim() + '\n');
    }

    static isExist(filePath) {
        let { error } = Joi.string().required().validate(filePath);
        if (error) throw error;

        return fs.existsSync(filePath);
    }

    static mkDir(dirPath) {
        let { error } = Joi.string().required().validate(dirPath);
        if (error) throw error;

        try {
            fs.mkdirSync(dirPath, { recursive: true });
            return true;
        } catch (err) {
            return false;
        }
    }

    static allFiles(dirPath, extension) {
        let { error } = Joi.object({
            dirPath: Joi.string().required(),
            extension: Joi.string().optional()
        }).validate({ dirPath, extension });
        if (error) throw error;

        let fileList = [];
        try {
            let items = fs.readdirSync(dirPath);
            for (let item of items) {
                let fullPath = path.join(dirPath, item);
                if (fs.statSync(fullPath).isDirectory()) {
                    fileList = fileList.concat(this.allFiles(fullPath, extension));
                } else fileList.push(fullPath);
            }
        } catch (err) { if (Xfile.show) console.log(`Lỗi khi lấy danh sách file ${dirPath}:`, err); }

        return extension ? fileList.filter(v => v.endsWith(extension)) : fileList;;
    }

    static allDir(dirPath) {
        let { error } = Joi.string().required().validate(dirPath);
        if (error) throw error;

        let dirList = [];
        try {
            let items = fs.readdirSync(dirPath);
            for (let item of items) {
                let fullPath = path.join(dirPath, item);
                let stats = fs.statSync(fullPath);
                if (stats.isDirectory()) {
                    dirList.push(fullPath);
                    dirList = dirList.concat(this.allDir(fullPath));
                }
            }
        } catch (err) { if (Xfile.show) console.log(`Lỗi khi lấy danh sách thư mục ${dirPath}:`, err); }

        return dirList;
    }

    static delFile(filePath) {
        let { error } = Joi.string().required().validate(filePath);
        if (error) throw error;

        try {
            if (fs.existsSync(filePath)) {
                fs.unlinkSync(filePath);
                return true;
            }
            return false;
        } catch (err) {
            if (Xfile.show) console.log(`Lỗi khi xóa file ${filePath}:`, err);
            return false;
        }
    }

    static emptyDir(dirPath) {
        try {
            this.delDir(dirPath);
            this.mkDir(dirPath);
            return true;
        }
        catch (err) {
            if (Xfile.show) console.log(`Lỗi làm trống dir ${filePath}:`, err);
            return false;
        }
    }

    static delDir(dirPath) {
        let { error } = Joi.string().required().validate(dirPath);
        if (error) throw error;

        try {
            if (fs.existsSync(dirPath)) {
                fs.rmSync(dirPath, { recursive: true, force: true });
                return true;
            }
            return false;
        } catch (err) {
            if (Xfile.show) console.log(`Lỗi khi xóa thư mục ${dirPath}:`, err);
            return false;
        }
    }
    static rename(path, newPath) {
        let { error } = Joi.array().items(Joi.string().required()).required().validate([path, newPath]);
        if (error) throw error;
        try {
            fs.renameSync(path, newPath);
            return true;
        } catch (err) {
            if (Xfile.show) console.log(`Lỗi khi đổi tên file ${path} -> ${newPath}:`, err);
            return false;
        }
    }
}

module.exports = Xfile;
