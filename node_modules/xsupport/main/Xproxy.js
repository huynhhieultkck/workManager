const Xfetch = require('./Xfetch');
const { HttpsProxyAgent } = require('https-proxy-agent');
const Joi = require('joi');
const { SocksProxyAgent } = require('socks-proxy-agent');


class Xproxy {
    constructor(type = 'http', host, port, username, password) {
        let { error } = Joi.object({
            type: Joi.string().required().valid('http', 'socks4', 'socks5'),
            host: Joi.string().required(),
            port: Joi.number().integer().required(),
            username: Joi.string(),
            password: Joi.string()
        }).validate({ type, host, port, username, password })
        if (error) throw error;

        this.type = type;
        this.host = host;
        this.port = port;
        this.username = username;
        this.password = password;
    }


    static fromUrl(proxyUrl) {
        try {
            let url = new URL(proxyUrl);
            let type = url.protocol.replace(':', '').toLowerCase();
            let host = url.hostname;
            let port = url.port;
            let username = url.username || '';
            let password = url.password || '';

            if (!host || !port) {
                throw new Error('URL proxy không hợp lệ.');
            }

            return new Xproxy(type, host, port, username, password);
        } catch (error) {
            throw new Error(`Không thể phân tích URL proxy: ${error.message}`);
        }
    }

    url() {
        if (this.username && this.password)
            return `${this.type}://${encodeURIComponent(this.username)}:${encodeURIComponent(this.password)}@${this.host}:${this.port}`;
        else
            return `${this.type}://${this.host}:${this.port}`;
    }
    url2() {
        if (this.username && this.password)
            return `${this.type}://${this.host}:${this.port}:${encodeURIComponent(this.username)}:${encodeURIComponent(this.password)}`;
        else
            return `${this.type}://${this.host}:${this.port}`;
    }

    agent() {
        switch (this.type) {
            case 'http':
                return new HttpsProxyAgent(this.url());
            case 'socks4':
            case 'socks5':
                return new SocksProxyAgent(this.url());
        }
    }
    async check() {
        try {
            let fetch = new Xfetch();
            fetch.timeout = 5000;
            fetch.redirect = false;
            fetch.proxy = this.agent();
            // return fetch.proxy ? fetch.get('https://www.microsoft.com').then(_ => fetch.response.includes('microsoft.com/favicon.ico')).catch(_ => false) : false;
            return fetch.proxy ? fetch.get('https://www.google.com/generate_204').then(_ => fetch.status < 300).catch(_ => false) : false;
        }
        catch (err) {
            return false;
        }
    }

    // static check(xpx) {
    //     let fetch = new Xfetch();
    //     fetch.proxy = xpx.agent();
    //     if (!fetch.proxy) throw new Error('Không thể tạo agent cho proxy.');

    //     return fetch.get('https://www.google.com/generate_204')//https://www.google.com/generate_204 //https://1.1.1.1/cdn-cgi/trace
    //         .then(rs => true)
    //         .catch(rs => false)
    // }

}


module.exports = Xproxy;

