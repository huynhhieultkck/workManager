const fetch = require('node-fetch');
const Xfile = require('./Xfile');
const Xerror = require('./Xerror');
const Joi = require('joi');
const { CookieJar } = require('tough-cookie');
const Xfilter = require('./Xfilter');
const { XMLBuilder } = require('fast-xml-parser');
const Xtime = require('./Xtime');
const Xcode = require('./Xcode');


class Xfetch {
    #ERROR_PROXY_LIST = ['ECONNRESET',
        'ECONNREFUSED',
        'net::ERR_INVALID_RESPONSE',
        'net::ERR_NETWORK_CHANGED',
        'net::ERR_CONNECTION_REFUSED',
        'net::ERR_PROXY_CONNECTION_FAILED',
        'net::ERR_TUNNEL_CONNECTION_FAILED',
        'TypeError: Failed to fetch',
        'ETIMEDOUT',
        'PROXY_ERROR',
        'AbortError'];



    constructor(name = Xcode.string.random(10)) {
        let { error } = Joi.string().required().validate(name);
        if (error) throw error;

        this.cookie_file = `Xcookies/${name}.json`;
        this.jar = this.#loadCookies();
        this.redirect = true;
        this.redirectFc = () => true
        this.show = false;
        this.save = false;
        this.proxy = null;
        this.proxyGlobal = null;
        this.timeout = 10000;
        this.headersOption = {
            'Accept': '*/*',
            'Connection': 'keep-alive',
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/135.0.0.0 Safari/537.36'
        };

        this.url = '';
        this.status = null;
        this.headers = {};
        this.response = '';
        this.cookies = {};
        this.filter = { urlRedirect: [], url: {}, headers: {}, values: {}, regex: {} };
        this.data = {};
    }

    get(url, option) { return this.#request(url, option); }

    post(url, body, option) {
        return this.#request(url, { method: 'post', body, ...option });
    }
    put(url, body, option) {
        return this.#request(url, { method: 'put', body, ...option });
    }
    delete(url, option) {
        return this.#request(url, { method: 'delete', ...option });
    }


    //'1.urlencoded','2.xml','3.form-data'
    static parseBody(body, type = 1) {
        let { error } = Joi.object({
            body: Joi.object().required(),
            type: Joi.number().valid(1, 2, 3)
        }).validate({ body, type });
        if (error) throw error;

        switch (type) {
            case 1:
                return new URLSearchParams(body).toString();
            case 2:
                return new XMLBuilder().build(body);
            case 3:
                let formData = new URLSearchParams();
                for (let key in body) {
                    if (Array.isArray(body[key])) body[key].forEach(v => formData.append(`${key}[]`, v));
                    else if (typeof (body[key]) === 'object') formData.append(key, JSON.stringify(body[key]));
                    else formData.append(key, body[key]);
                }
                return formData;
        }
    }





    addCookie(key, value, domain) {
        let { error } = Joi.object({
            key: Joi.string().required(),
            value: Joi.string().required(),
            domain: Joi.string().required()
        }).validate({ key, value, domain });
        if (error) throw error;

        this.jar.setCookieSync(`${key}=${value}; domain=${domain};`, `https://${domain}`)
    }


    saveCookies() {
        Xfile.write(this.cookie_file, JSON.stringify(this.jar.toJSON(), null, 2), true);
    }
    savePage(nameFile) {
        try {
            if (!nameFile) nameFile = `${Xcode.string.random(8)}.html`;
            Xfile.write(`Response/${nameFile}`, this.response, true);
            Xfile.write('Response/urlFilter.txt', Xfilter.url(this.response)?.join('\n'), true);
            Xfile.write('Response/nameValueFilter.txt', Xfilter.nameValue(this.response)?.join('\n'), true);
            Xfile.writeLine('Response/url.txt', this.url);
            Xfile.write('Response/headers.json', JSON.stringify(this.headers), true);
            this.#show(`${this.status}\t=>\t${nameFile}`);
        } catch (e) { this.#show(e); }
    }

    #loadCookies() {
        if (Xfile.isExist(this.cookie_file)) return CookieJar.fromJSON(Xfile.read(this.cookie_file));
        return new CookieJar();
    }

    async #parseOption(url, options = {}) {
        if (this.proxy) options.agent = this.proxy;
        if (this.proxyGlobal) {
            await this.#waitProxy();
            options.agent = this.proxyGlobal.agent;
            this.proxyGlobal.worker++;
        }
        if (!options.headers) options.headers = {};
        if (options.body && typeof (options.body) == 'object') {
            options.body = JSON.stringify(options.body);
            options.headers['Content-Type'] = 'application/json';
        } else options.headers['Content-Type'] = 'application/x-www-form-urlencoded';
        return {
            method: options.method || 'get',
            redirect: 'manual',
            signal: AbortSignal.timeout(this.timeout),
            ...options,
            headers: {
                Cookie: this.jar.getCookieStringSync(url),
                ...this.headersOption,
                ...options.headers,
            }
        };;
    }

    #handleAfterFetch(response, url, options) {
        let cookies = response.headers.raw()['set-cookie'];
        if (cookies) cookies.forEach(v => this.jar.setCookieSync(v, url));
        if (this.save) this.saveCookies();

        this.cookies = this.jar.toJSON();
        this.headers = {};
        response.headers.forEach((v, k) => { this.headers[k] = v; });
        this.url = url;
        this.status = response.status;
        return response.text()
            .then(text => {
                this.response = text || '';
                try {
                    let json = JSON.parse(text);
                    return json;
                } catch { return text; }
            })
            .then(rs => {
                Object.keys(this.filter.url).forEach(v => this.#checkUrl(v, this.filter.url[v]));
                Object.keys(this.filter.values).forEach(v => this.#checkValue(v, this.filter.values[v]));
                Object.keys(this.filter.headers).forEach(v => this.#checkHeader(v, this.filter.headers[v]));
                Object.keys(this.filter.regex).forEach(v => this.#checkRegex(v, this.filter.regex[v]));
                return rs;
            })
    }
    #showFetch(response, url, options) {
        if (this.show) this.savePage();
        return response;
    }
    #handleRedirect(response, url, options) {
        if (this.redirect && this.redirectFc() && this.status >= 300 && this.status < 400 && this.headers['location'] && (new URL(this.headers['location']).protocol == 'http:' || new URL(this.headers['location']).protocol == 'https:')) {
            this.#show(`Chuyển hướng đến :${this.headers['location']}`)
            return this.#request(this.headers['location']);
        }
        return response;
    }

    #handleErrorResolve(response, url, options) {
        // if (this.status == 429) return Promise.reject(Xerror.TOO_MANY_REQUESTS);
        if ([305, 407, 502, 503, 504, 429].includes(this.status)) return Promise.reject(Xerror.PROXY);
        return response;
    }
    #handleErrorReject(err) {
        if ((err.code || err.name) && this.#ERROR_PROXY_LIST.includes(err.code || err.name)) return Promise.reject(Xerror.PROXY);
        return Promise.reject(err);
    }
    #request(url, options) {
        if (this.url) url = new URL(url, this.url).href;
        return this.#parseOption(url, options)
            .then(ot => {
                options = ot;
                this.#show({ url, options });
                return fetch(url, options).finally(_ => { if (this.proxyGlobal) this.proxyGlobal.worker--; });
            })
            .then(response => this.#handleAfterFetch(response, url, options))
            .then(response => this.#showFetch(response, url, options))
            .then(response => this.#handleRedirect(response, url, options))
            .then(response => this.#handleErrorResolve(response, url, options))
            .catch(err => this.#handleErrorReject(err))
    }
    async #waitProxy() {
        while (this.proxyGlobal.renew) {
            this.#show(`Đang đợi thay proxy !`);
            await Xtime.sleep(1000);
        }
    }

    #show(message) {
        if (this.show) console.log(message);
    }


    #checkHeader(name, nameHeader) {
        if (this.headers[nameHeader]) this.data[name] = this.headers[nameHeader];
    }

    #checkValue(name, nameValue) {
        let result = Xfilter[name.includes('Id') ? 'uuid' : 'value'](this.response, nameValue);
        if (result != null) this.data[name] = result;
    }

    #checkUrl(name, params) {
        if (this.url) {
            let v = new URL(this.url).searchParams.get(params);
            if (v) this.data[name] = v;
        }
    }
    #checkRegex(name, reg) {
        let result = new RegExp(reg).exec(this.response || '');
        if (result?.at(0)) this.data[name] = result[result.length - 1];
    }
}

module.exports = Xfetch;


