const readline = require('readline');

class XConsole {
    static lines = [];
    static rl = null;

    static getInterface() {
        if (!this.rl) {
            this.rl = readline.createInterface({
                input: process.stdin,
                output: process.stdout
            });
        }
        return this.rl;
    }


    // Xuất thông tin không xuống dòng
    static write(text) {
        process.stdout.write(text);
    }

    // Xuất thông tin xuống dòng mới hoặc thay thế dòng chỉ định
    static writeLine(text, line = null) {
        if (line !== null && line >= 0 && line < this.lines.length) {
            this.lines[line] = text;
            process.stdout.write(`\x1b[${this.lines.length - line}A\r`);
            process.stdout.write(`\x1b[K${text}\n`);
            process.stdout.write(`\x1b[${this.lines.length - line - 1}B`);
        } else {
            console.log(text);
            this.lines.push(text);
        }
    }

    // Nhận thông tin nhập vào từ người dùng (không xuống dòng)
    static read(callback) {
        process.stdin.once('data', (data) => {
            callback(data.toString().trim());
        });
    }

    // Nhận thông tin từ một dòng mới hoặc thay thế dòng chỉ định
    static readLine(prompt, callback, line = null) {
        this.getInterface().question(prompt, (input) => {
            if (line !== null && line >= 0 && line < this.lines.length) {
                this.writeLine(input, line);
            } else {
                this.writeLine(input);
            }
            callback(input);
        });
    }

    // Xóa tất cả nội dung trong console hoàn toàn (không thể cuộn lên để xem log cũ)
    static delete() {
        process.stdout.write('\x1b[2J\x1b[3J\x1b[H'); // Xóa hoàn toàn buffer cuộn
        this.lines = [];
    }

    // Xóa dòng cuối hoặc dòng chỉ định trong console
    static deleteLine(line = null) {
        if (this.lines.length > 0) {
            if (line === null) {
                line = this.lines.length - 1;
            }
            if (line >= 0 && line < this.lines.length) {
                process.stdout.write(`\x1b[${this.lines.length - line}A\r\x1b[K`);
                process.stdout.write(`\x1b[${this.lines.length - line - 1}B`);
                this.lines.splice(line, 1);
            }
        }
    }

    // Xóa tất cả rồi ghi lại nội dung mới
    static update(text) {
        this.delete();
        this.writeLine(text);
    }

    // Xóa dòng cuối hoặc dòng chỉ định rồi ghi lại nội dung mới
    static updateLine(text, line = null) {
        this.deleteLine(line);
        this.writeLine(text, line);
    }

    // Thay đổi tiêu đề của console
    static setTitle(title) {
        process.title = title;
    }

    static updateLines(linesArray) {
        if (!Array.isArray(linesArray)) return;

        const oldLineCount = this.lines.length;
        const newLineCount = linesArray.length;

        // Di chuyển con trỏ lên để cập nhật nội dung
        if (oldLineCount > 0) {
            process.stdout.write(`\x1b[${oldLineCount}A`); // Di chuyển lên trên đầu của log cũ
        }

        // Ghi đè từng dòng thay vì tạo dòng mới
        linesArray.forEach((line, index) => {
            if (index < oldLineCount) {
                process.stdout.write(`\r\x1b[K${line}`); // Xóa dòng cũ và ghi đè
            } else {
                console.log(line); // Nếu dòng mới dài hơn, in thêm dòng
            }
        });

        // Xóa các dòng dư (nếu log cũ dài hơn log mới)
        if (oldLineCount > newLineCount) {
            for (let i = newLineCount; i < oldLineCount; i++) {
                process.stdout.write(`\r\x1b[K\n`); // Xóa nội dung dòng dư
            }
            process.stdout.write(`\x1b[${oldLineCount - newLineCount}A`); // Di chuyển con trỏ lên
        }

        // Cập nhật bộ nhớ để theo dõi dòng hiện tại
        this.lines = [...linesArray];
    }





}

module.exports = XConsole;

